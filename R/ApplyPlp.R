#TODO
#' Apply train model on new data
#' Apply a Patient Level Prediction model on Patient Level Prediction Data and get the predicted risk
#' in [0,1] for each person in the population. If the user inputs a population with an outcomeCount
#' column then the function also returns the evaluation of the prediction (AUC, brier score,
#' calibration)
#'
#' @param population       The population of people who you want to predict the risk for
#' @param plpData          The plpData for the population
#' @param plpModel         The trained PatientLevelPrediction model
#' @param calculatePerformance  Whether to also calculate the performance metrics [default TRUE]
#' @param logConnection    A connection to output any logging during the process
#' @param databaseOutput   Whether to save the details into the prediction database
#' @param silent           Whether to turn off progress reporting
#'
#' @examples
#' \dontrun{
#' # load the model and data
#' plpData <- loadPlpData("C:/plpdata")
#' plpModel <- loadPlpModel("C:/plpmodel")
#'
#' # use the same population settings as the model:
#' populationSettings <- plpModel$populationSettings
#' populationSettings$plpData <- plpData
#' population <- do.call(createStudyPopulation, populationSettings)
#'
#' # get the prediction:
#' prediction <- applyModel(population, plpData, plpModel)$prediction
#' }
#' @export
applyModel <- function(population,
                       plpData,
                       plpModel,
                       calculatePerformance=T,
                       logConnection = NULL,
                       databaseOutput = NULL,
                       silent = F) {
  # check input:
  if (is.null(population))
    stop("NULL population")
  if (class(plpData) != "plpData")
    stop("Incorrect plpData class")
  if (class(plpModel) != "plpModel")
    stop("Incorrect plpModel class")
  if (!ifelse(is.null(logConnection), TRUE, "connection" %in% class(logConnection)))
    stop("logConnection not NULL or a connection")

  # log the trained model details TODO

  # get prediction counts:
  peopleCount <- nrow(population)

  start.pred <- Sys.time()
  if (!is.null(logConnection))
    cat("Starting Prediction at ", Sys.time(), "for ", peopleCount, " people", file = logConnection)
  if (!silent)
    writeLines(paste("Starting Prediction ", Sys.time(), "for ", peopleCount, " people"))

  prediction <- plpModel$predict(plpData = plpData, population = population)

  if (!is.null(logConnection)) {
    cat("Prediction completed at ", Sys.time(), file = logConnection)
    cat("Took: ", start.pred - Sys.time(), file = logConnection)
  }
  if (!silent)
    writeLines(paste("Prediction completed at ", Sys.time(), " taking ", start.pred - Sys.time()))


  if (!"outcomeCount" %in% colnames(prediction))
    return(list(prediction = prediction))
  
  if(!calculatePerformance || nrow(prediction) == 1)
    return(prediction)

  if (!is.null(logConnection)) {
    cat("Starting evaluation at ", Sys.time(), file = logConnection)
  }
  if (!silent)
    writeLines(paste("Starting evaulation at ", Sys.time()))

  performance <- evaluatePlp(prediction, plpData)

  # reformatting the performance 
  analysisId <-   '000000'
  nr1 <- length(performance$evaluationStatistics)
  performance$evaluationStatistics <- cbind(analysisId= rep(analysisId,nr1-1),
                                               Eval=rep('validation', nr1-1),
                                               Metric = names(unlist(performance$evaluationStatistics[-1])),
                                               Value = unlist(performance$evaluationStatistics[-1])
                                               )
  nr1 <- nrow(performance$thresholdSummary)
  performance$thresholdSummary <- cbind(analysisId=rep(analysisId,nr1),
                                              Eval=rep('validation', nr1),
                                              performance$thresholdSummary)
  nr1 <- nrow(performance$demographicSummary)
  performance$demographicSummary <- cbind(analysisId=rep(analysisId,nr1),
                                        Eval=rep('validation', nr1),
                                        performance$demographicSummary)
  nr1 <- nrow(performance$calibrationSummary)
  performance$calibrationSummary <- cbind(analysisId=rep(analysisId,nr1),
                                          Eval=rep('validation', nr1),
                                          performance$calibrationSummary)
  nr1 <- nrow(performance$predictionDistribution)
  performance$predictionDistribution <- cbind(analysisId=rep(analysisId,nr1),
                                          Eval=rep('validation', nr1),
                                          performance$predictionDistribution)
  
  if (!is.null(logConnection)) {
    cat("Evaluation completed at ", Sys.time(), file = logConnection)
    cat("Took: ", start.pred - Sys.time(), file = logConnection)
  }
  if (!silent)
    writeLines(paste("Evaluation completed at ", Sys.time(), " taking ", start.pred - Sys.time()))

  result <- list(prediction = prediction, performance = performance)
  return(result)
}


#' Extract new plpData using plpModel settings
#' use metadata in plpModel to extract similar data and population for new databases:
#'
#' @param plpModel         The trained PatientLevelPrediction model or object returned by runPlp()
#' @param createCohorts          Create the tables for the target and outcome - requires sql in the plpModel object
#' @param newConnectionDetails      The connectionDetails for the new database
#' @param newCdmDatabaseSchema      The database schema for the new CDM database 
#' @param newCohortDatabaseSchema   The database schema where the cohort table is stored
#' @param newCohortTable            The table name of the cohort table
#' @param newCohortId               The cohort_definition_id for the cohort of at risk people
#' @param newOutcomeDatabaseSchema  The database schema where the outcome table is stored
#' @param newOutcomeTable           The table name of the outcome table
#' @param newOutcomeId              The cohort_definition_id for the outcome  
#' @param sample                    The number of people to sample (default is NULL meaning use all data)
#'
#' @examples
#' \dontrun{
#' # set the connection
#' connectionDetails <- DatabaseConnector::createConnectionDetails()
#'    
#' # load the model and data
#' plpModel <- loadPlpModel("C:/plpmodel")
#'
#' # extract the new data in the 'newData.dbo' schema using the model settings 
#' newDataList <- similarPlpData(plpModel=plpModel, 
#'                               newConnectionDetails = connectionDetails,
#'                               newCdmDatabaseSchema = 'newData.dbo',
#'                               newCohortDatabaseSchema = 'newData.dbo',   
#'                               newCohortTable = 'cohort', 
#'                               newCohortId = 1, 
#'                               newOutcomeDatabaseSchema = 'newData.dbo', 
#'                               newOutcomeTable = 'outcome',     
#'                               newOutcomeId = 2)    
#'                
#' # get the prediction:
#' prediction <- applyModel(newDataList$population, newDataList$plpData, plpModel)$prediction
#' }
#' @export
similarPlpData <- function(plpModel=NULL,
                           createCohorts = T,
                           newConnectionDetails = NULL,
                           newCdmDatabaseSchema = NULL,
                           newCohortDatabaseSchema = NULL,
                           newCohortTable = NULL,
                           newCohortId = NULL,
                           newOutcomeDatabaseSchema = NULL,
                           newOutcomeTable = NULL,
                           newOutcomeId = NULL,
                           sample=NULL) {
  
  if(is.null(plpModel))
    return(NULL)
  if(class(plpModel)!='plpModel' && class(plpModel)!='runPlp' )
    return(NULL)
  if(class(plpModel)=='runPlp')
    plpModel <- plpModel$model 
  
  if(createCohorts){
    if(is.null(plpModel$metaData$cohortCreate$targetCohort$sql))
      stop('No target cohort code')
    if(is.null(plpModel$metaData$cohortCreate$outcomeCohorts[[1]]$sql))
      stop('No outcome cohort code')
    
    connection <- DatabaseConnector::connect(connectionDetails)
    
    exists <- toupper(newCohortTable)%in%DatabaseConnector::getTableNames(connection , newCohortDatabaseSchema)
    if(!exists){
    flog.info('Creating temp cohort table')
    sql <- "create table @target_cohort_schema.@target_cohort_table(cohort_definition_id bigint, subject_id bigint, cohort_start_date datetime, cohort_end_date datetime)"
    sql <- SqlRender::translateSql(sql, targetDialect = connectionDetails$dbms)$sql
    sql <- SqlRender::renderSql(sql,
                                target_cohort_schema = newCohortDatabaseSchema,
                                target_cohort_table= newCohortTable)$sql
    ftry(DatabaseConnector::executeSql(connection,sql),
         error = stop, finally = flog.info('Cohort table created'))
    }
    
    exists <- toupper(newOutcomeTable)%in%DatabaseConnector::getTableNames(connection , newOutcomeDatabaseSchema)
    if(!exists){
      sql <- "create table @target_cohort_schema.@target_cohort_table(cohort_definition_id bigint, subject_id bigint, cohort_start_date datetime, cohort_end_date datetime)"
      sql <- SqlRender::translateSql(sql, targetDialect = connectionDetails$dbms)$sql
      sql <- SqlRender::renderSql(sql,
                                  target_cohort_schema = newOutcomeDatabaseSchema,
                                  target_cohort_table= newOutcomeTable)$sql
      ftry(DatabaseConnector::executeSql(connection,sql),
           error = stop, finally = flog.info('outcome table created'))
      
    }
    
    flog.info('Populating cohort tables')
    targetSql <- plpModel$metaData$cohortCreate$targetCohort$sql
    targetSql <- SqlRender::renderSql(targetSql, 
                                      cdm_database_schema=ifelse(is.null(newCdmDatabaseSchema),plpModel$metaData$call$cdmDatabaseSchema,newCdmDatabaseSchema),
                                      target_database_schema= ifelse(is.null(newCohortDatabaseSchema),plpModel$metaData$call$cdmDatabaseSchema,newCohortDatabaseSchema),
                                      target_cohort_table = ifelse(is.null(newCohortTable),plpModel$metaData$call$newCohortTable,newCohortTable),
                                      target_cohort_id = ifelse(is.null(newCohortId),plpModel$metaData$call$cohortId, newCohortId) )$sql
    
    targetSql <- SqlRender::translateSql(targetSql, 
                                         targetDialect = ifelse(is.null(newConnectionDetails$dbms), 'pdw',newConnectionDetails$dbms)  )$sql
    DatabaseConnector::executeSql(connection, targetSql)
    
    for(outcomesql in plpModel$metaData$cohortCreate$outcomeCohorts){
      outcomeSql <- outcomesql$sql
      outcomeSql <- SqlRender::renderSql(outcomeSql, 
                                         cdm_database_schema=ifelse(is.null(newCdmDatabaseSchema),plpModel$metaData$call$cdmDatabaseSchema,newCdmDatabaseSchema),
                                         target_database_schema= ifelse(is.null(newOutcomeDatabaseSchema),plpModel$metaData$call$cdmDatabaseSchema,newOutcomeDatabaseSchema),
                                         target_cohort_table = ifelse(is.null(newOutcomeTable),plpModel$metaData$call$newOutcomeTable,newOutcomeTable),
                                         target_cohort_id = ifelse(is.null(newOutcomeId),plpModel$metaData$call$outcomeId, newOutcomeId))$sql
      outcomeSql <- SqlRender::translateSql(outcomeSql, 
                                            targetDialect = ifelse(is.null(newConnectionDetails$dbms), 'pdw',newConnectionDetails$dbms))$sql
      DatabaseConnector::executeSql(connection, outcomeSql)
      
    }
   
    
  }
  
  writeLines('Loading model data extraction settings')
  dataOptions <- as.list(plpModel$metaData$call)
  dataOptions[[1]] <- NULL
  dataOptions$sampleSize <- sample
  
  #restricting to model variables and setting min to 0
  #dataOptions$covariateSettings$deleteCovariatesSmallCount <- 0
  dataOptions$covariateSettings$includedCovariateConceptIds <- plpModel$varImp$conceptId[plpModel$varImp$covariateValue!=0]
  
  
  writeLines('Adding new settings if set...')
  if(is.null(newCdmDatabaseSchema))
    return(NULL)
  dataOptions$cdmDatabaseSchema <- newCdmDatabaseSchema
  
  if(!is.null(newConnectionDetails))
    dataOptions$connectionDetails <- newConnectionDetails # check name
  
  if(!is.null(newCohortId))
    dataOptions$cohortId <- newCohortId
  if(!is.null(newOutcomeId))
    dataOptions$outcomeIds <- newOutcomeId
  
  if(!is.null(newCohortDatabaseSchema))
    dataOptions$cohortDatabaseSchema <- newCohortDatabaseSchema  # correct names?
  if(!is.null(newCohortTable))
    dataOptions$cohortTable <- newCohortTable
  
  if(!is.null(newOutcomeDatabaseSchema))
    dataOptions$outcomeDatabaseSchema <- newOutcomeDatabaseSchema # correct names?
  if(!is.null(newOutcomeTable))
    dataOptions$outcomeTable <- newOutcomeTable
  
  dataOptions$baseUrl <- NULL
  
  plpData <- do.call(getPlpData, dataOptions)
  
  # get the popualtion
  writeLines('Loading model population settings')
  popOptions <- plpModel$populationSettings
  popOptions$cohortId <- dataOptions$cohortId
  popOptions$outcomeId <- dataOptions$outcomeIds
  popOptions$plpData <- plpData
  population <- do.call(PatientLevelPrediction::createStudyPopulation, popOptions)
  
  
  # return the popualtion and plpData for the new database
  writeLines('Returning population and plpData for new data using model settings')
  return(list(population=population,
              plpData=plpData))
}
